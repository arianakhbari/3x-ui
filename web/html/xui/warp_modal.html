<script>
    const warpModal = {
        visible: false,
        confirmLoading: false,
        warpData: null,
        warpConfig: null,
        warpOutbound: null,
        maxRetries: 3,  // Added for retry mechanism
        async show() {
            this.visible = true;
            this.warpConfig = null;
            await this.getData();  // Ensure data is fetched when showing modal
        },
        close() {
            this.visible = false;
            this.loading(false);
        },
        loading(loading = true) {
            this.confirmLoading = loading;
        },
        async getData() {
            this.loading(true);
            try {
                const msg = await this.retryRequest(() => HttpUtil.post('/panel/xray/warp/data'));
                if (msg.success) {
                    this.warpData = msg.obj.length > 0 ? JSON.parse(msg.obj) : null;
                }
            } catch (error) {
                console.error("Error fetching WARP data:", error);
            } finally {
                this.loading(false);
            }
        },
        async register() {
            this.loading(true);
            try {
                const keys = Wireguard.generateKeypair();
                const msg = await this.retryRequest(() => HttpUtil.post('/panel/xray/warp/reg', keys));
                if (msg.success) {
                    const resp = JSON.parse(msg.obj);
                    this.warpData = resp.data;
                    this.warpConfig = resp.config;
                    this.collectConfig();
                }
            } catch (error) {
                console.error("Error registering WARP:", error);
            } finally {
                this.loading(false);
            }
        },
        async updateLicense(license) {
            this.loading(true);
            try {
                const msg = await this.retryRequest(() => HttpUtil.post('/panel/xray/warp/license', { license }));
                if (msg.success) {
                    this.warpData = JSON.parse(msg.obj);
                    this.warpConfig = null;
                    this.warpPlus = '';
                }
            } catch (error) {
                console.error("Error updating WARP license:", error);
            } finally {
                this.loading(false);
            }
        },
        async getConfig() {
            this.loading(true);
            try {
                const msg = await this.retryRequest(() => HttpUtil.post('/panel/xray/warp/config'));
                if (msg.success) {
                    this.warpConfig = JSON.parse(msg.obj);
                    this.collectConfig();
                }
            } catch (error) {
                console.error("Error fetching WARP config:", error);
            } finally {
                this.loading(false);
            }
        },
        async delConfig() {
            this.loading(true);
            try {
                const msg = await this.retryRequest(() => HttpUtil.post('/panel/xray/warp/del'));
                if (msg.success) {
                    this.warpData = null;
                    this.warpConfig = null;
                    this.delOutbound();
                }
            } catch (error) {
                console.error("Error deleting WARP config:", error);
            } finally {
                this.loading(false);
            }
        },
        async retryRequest(requestFunction) {
            let attempts = 0;
            while (attempts < this.maxRetries) {
                try {
                    return await requestFunction();
                } catch (error) {
                    attempts++;
                    if (attempts >= this.maxRetries) {
                        throw error;  // Re-throw error after max attempts
                    }
                    await new Promise(res => setTimeout(res, 1000 * attempts));  // Exponential backoff
                }
            }
        },
        collectConfig() {
            const config = warpModal.warpConfig.config;
            const peer = config.peers[0];
            if (config) {
                warpModal.warpOutbound = Outbound.fromJson({
                    tag: 'warp',
                    protocol: Protocols.Wireguard,
                    settings: {
                        mtu: 1420,
                        secretKey: warpModal.warpData.private_key,
                        address: this.getAddresses(config.interface.addresses),
                        reserved: this.getResolved(config.client_id),
                        domainStrategy: 'ForceIP',
                        peers: [{
                            publicKey: peer.public_key,
                            endpoint: peer.endpoint.host,
                        }],
                        kernelMode: false
                    }
                });
            }
        },
        getAddresses(addrs) {
            let addresses = [];
            if (addrs.v4) addresses.push(addrs.v4 + "/32");
            if (addrs.v6) addresses.push(addrs.v6 + "/128");
            return addresses;
        },
        getResolved(client_id) {
            let reserved = [];
            let decoded = atob(client_id);
            let hexString = '';
            for (let i = 0; i < decoded.length; i++) {
                let hex = decoded.charCodeAt(i).toString(16);
                hexString += (hex.length === 1 ? '0' : '') + hex;
            }
            for (let i = 0; i < hexString.length; i += 2) {
                let hexByte = hexString.slice(i, i + 2);
                let decValue = parseInt(hexByte, 16);
                reserved.push(decValue);
            }
            return reserved;
        }
    };

    new Vue({
        delimiters: ['[[', ']]'],
        el: '#warp-modal',
        data: {
            warpModal: warpModal,
            warpPlus: '',
        },
        methods: {
            async register() {
                await warpModal.register();
            },
            async updateLicense() {
                await warpModal.updateLicense(this.warpPlus);
            },
            async getConfig() {
                await warpModal.getConfig();
            },
            async delConfig() {
                await warpModal.delConfig();
            }
        },
        computed: {
            warpOutboundIndex() {
                return app.templateSettings ? app.templateSettings.outbounds.findIndex((o) => o.tag === 'warp') : -1;
            }
        }
    });
</script>
